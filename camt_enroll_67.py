# -*- coding: utf-8 -*-
"""CAMT_Enroll_67.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UlEZUk1GLqFUkBPdJYpNuddnmCvBdoo1
"""



"""1.Import File"""

import pandas as pd
from google.colab import files
import io

# ขั้นตอนที่ 1: รันโค้ดเพื่อเปิดหน้าต่างเลือกไฟล์
uploaded = files.upload()

"""2. Read file

3.Drop NA in column course
"""

# ขั้นตอนที่ 2: อ่านไฟล์ Excel ที่อัปโหลดเข้ามา
# เปลี่ยน 'your_file_name.xlsx' เป็นชื่อไฟล์ที่คุณอัปโหลด
for filename in uploaded.keys():
    # Read the specific sheet named 'sm2unpivot'
    df = pd.read_excel(io.BytesIO(uploaded[filename]), sheet_name='sm2unpivot')
    print(f"File '{filename}' successfully loaded into DataFrame df from sheet 'sm2unpivot'.")
    print(df.head())
    break # ถ้ามีหลายไฟล์ เราจะอ่านไฟล์แรกเท่านั้น

# *หมายเหตุ: หากคุณมีหลายชีตในไฟล์ Excel
# คุณสามารถระบุชื่อชีตได้ เช่น pd.read_excel(..., sheet_name='Sheet2')

df

df['Course'] = df['Course'].apply(lambda x: x if pd.notna(x) and str(x).isdigit() and len(str(x)) == 6 else pd.NA) #เหลือเฉพาะรหัส 6 หลัก และ ค่าอื่นให้กลายเป็น NaN
df #เอาแค่รหัสหกตัว หากไม่ใช่ NA in course

df['Course'] = df['Course'].ffill().infer_objects(copy=False) #forward fill column course
df

df=df.dropna(subset=['Time','Room','LECTURER']).reset_index(drop=True)#drop blank rows by Subset
df

# Function to split rows based on the 'Day' column
def split_day_rows(df):
    new_rows = []
    for index, row in df.iterrows():
        # Convert 'Day' column to string to handle potential float values
        day_value = str(row['Day'])
        days = day_value.split(' and ') # Split by ' and ' first
        if len(days) > 1: # If ' and ' split didn't work, try splitting by individual day codes
            days = []
            day_codes = ['Mo', 'Tu', 'We', 'Th', 'Fr']
            current_day_code = ''
            for char in day_value:
                current_day_code += char
                if current_day_code in day_codes:
                    days.append(current_day_code)
                    current_day_code = ''
            if not days: # If still no split, keep the original row
                new_rows.append(row)
        elif day_value in ['MTh', 'MW', 'TuF']: # Handle combined day codes
             if day_value == 'MTh':
                 days = ['Mo', 'Th']
             elif day_value == 'MW':
                 days = ['Mo', 'We']
             elif day_value == 'TuF':
                 days = ['Tu', 'Fr']
        if len(days) > 1:
            for day in days:
                new_row = row.copy()
                new_row['Day'] = day
                new_rows.append(new_row)
        else:
            new_rows.append(row)
    return pd.DataFrame(new_rows)

# Apply the function to the DataFrame to create df_split
df_split = split_day_rows(df.copy())

# Split the 'Time' column into 'Start Time' and 'End Time'
# Handle cases where splitting by '-' might not result in two parts
time_split = df_split['Time'].str.split('-', expand=True)
df_split['Start Time'] = time_split[0]
# Use .get(1) with a default of None to handle cases where there's no second part
df_split['End Time'] = time_split.get(1)

# Display the updated DataFrame
display(df_split.head())

# Convert 'Start Time' and 'End Time' to datetime objects for calculation
df_split['Start Time'] = pd.to_datetime(df_split['Start Time'], format='%H%M', errors='coerce').dt.time
df_split['End Time'] = pd.to_datetime(df_split['End Time'], format='%H%M', errors='coerce').dt.time

# Function to calculate duration
def calculate_duration(start_time, end_time):
    if pd.isna(start_time) or pd.isna(end_time):
        return None
    # Convert time objects to datetime objects with a dummy date for calculation
    dummy_date = pd.to_datetime('2000-01-01')
    start_datetime = pd.to_datetime(str(dummy_date.date()) + ' ' + str(start_time))
    end_datetime = pd.to_datetime(str(dummy_date.date()) + ' ' + str(end_time))

    if end_datetime < start_datetime:
        # Handle cases where the end time is on the next day (e.g., crosses midnight)
        end_datetime += pd.Timedelta(days=1)

    duration = end_datetime - start_datetime
    # Return duration in hours
    return duration.total_seconds() / 3600

# Apply the function to create the 'Duration' column
df_split['Duration'] = df_split.apply(lambda row: calculate_duration(row['Start Time'], row['End Time']), axis=1)

# Display the updated DataFrame with the new 'Duration' column
display(df_split)

# Export the DataFrame to an Excel file
output_filename = 'df_2.67_cleaned.xlsx'
df_split.to_excel(output_filename, index=False)

# Download the file
files.download(output_filename)

print(f"DataFrame successfully exported to '{output_filename}' and ready for download.")

